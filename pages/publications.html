<!DOCTYPE html>
<html lang="en"><head>
 <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http:/xlauko.github.io/feed.xml" title="Henrich Lauko" /><script src="/assets/javascript/bootstrap/jquery.min.js"></script>
  <script src="/assets/javascript/bootstrap/bootstrap.bundle.min.js"></script>
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
</head>
<body><nav class="navbar navbar-expand-lg navbar-dark bg-primary">
  <div class="container">
    <a class="navbar-brand" rel="author" href="/">Henrich Lauko</a>

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
      aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto"><li class="nav-item">
            <a class="nav-link" href="/">About</a>
          </li>
        <li class="nav-item">
            <a class="nav-link" href="/pages/publications">Publications</a>
          </li>
        <li class="nav-item">
            <a class="nav-link" href="/pages/projects">Projects</a>
          </li>
        <li class="nav-item">
            <a class="nav-link" href="https://github.com/xlauko">Github</a>
          </li>
        </ul>
    </div>
  </div>
</nav>
<div class="py-5">
      <div class="container page-content">
          <article>

  <header>
    <h4></h4>
  </header>

  <section>
    <p>Thesis</p>

<ul>
  <li>Abstractions via Program Transformations (<em>advanced master thesis</em>)
    <div id="amaster-materials">
  <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#abstract-amaster" aria-expanded="false" aria-controls="abstract-amaster">
  Abstract
  </button>

  <button class="btn btn-link" type="button">
  <a href="https://is.muni.cz/auth/th/uqf69/?lang=en">Web</a>
  </button>

  <div class="collapse" id="abstract-amaster">
    <hr />
    In computer-aided verification, most of the tools leverage abstraction techniques to reduce the complexity of analyzed systems. Even though these techniques are widely adopted, they are usually tightly integrated into tools, causing undesired complexity, and neglect any reusable design. In my research, I focus on the investigation of abstraction-based techniques used in program verification as abstract interpretation, counterexample guided abstraction or symbolic execution. For these techniques, I devise self-contained alternatives and general-purpose analyses. As a solution for self-contained abstraction, I propose a transformation-based method. This method utilizes instrumentation to insert abstraction directly to the program and consequently quits of responsibility for abstraction from the verification tools. Up until now, I have developed transformation-based symbolic execution and string abstraction for explicit model checkers. In the future, I plan to generalize the transformation-based technique for a wider variety of abstract domains such as predicate or pointer abstraction. Furthermore, I intend to adapt traditional abstraction refinement techniques to the self-contained abstraction.
    <hr />
  </div>
</div>
  </li>
  <li>Symbolic Model Checking via Program Transformations (<em>master thesis</em>)
    <div id="master-materials">
  <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#abstract-master" aria-expanded="false" aria-controls="abstract-master">
  Abstract
  </button>

  <button class="btn btn-link" type="button">
  <a href="https://is.muni.cz/auth/th/owq0x/?lang=en">Web</a>
  </button>

  <div class="collapse" id="abstract-master">
    <hr />
    To show reliability of software, developers usually reach out for testing and static analysis. However, to prove correctness, all behaviours of a program need to be checked. In this respect, formal verification methods aim to provide an automated approach to verification. A big obstacle are inputs because they massively increase the number of behaviours of the program. In this thesis, we present a technique which enables verification tools to perform automated checking of programs with inputs. A generally known approach is to interpret operations with input values in an abstract way. In this case, abstraction needs to be implemented in the verification tool. We propose that instead, an abstraction can be compiled into the program. Hence, the program can be verified by a tool even though the tool itself does not support abstraction of inputs. We implement the proposed approach as an LLVM-to-LLVM transformation which inserts an abstraction to the program. The applicability of the approach is demonstrated by transforming programs to represent their inputs symbolically. This, in turn, enables an essentially explicit-state model checker to verify the program. For evaluation purposes, we have chosen DIVINE as the model checker.
    <hr />
  </div>
  <i class="fa fa-trophy"> Dean's award for an Outstanding Final Thesis</i>
</div>
  </li>
  <li>Introduction to Data Structures in Examples (<em>bachelor thesis</em>)
    <div id="bachelor-materials">
  <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#abstract-bachelor" aria-expanded="false" aria-controls="abstract-bachelor">
  Abstract
  </button>

  <button class="btn btn-link" type="button">
  <a href="https://is.muni.cz/auth/th/vlg4z/?lang=en">Web</a>
  </button>

  <div class="collapse" id="abstract-bachelor">
    <hr />
    This thesis presents methods and structures proposed for teaching and home study of data structures. The thesis describes creation process of concrete exercises and their solutions. A part of exercises cover practical implementations, that contains code templates to be solved and a package of tests. Themes covered in the thesis are elementary data structures such as stack, queue, linked list and their modifications. Moreover, the thesis covers dynamic data structures for searching: binary heap, searching trees, red-black trees and B-trees. The thesis also comprehends data structures for the implementation of dictionaries.
  </div>
</div>
  </li>
</ul>

<hr />

<p>2020</p>
<ol class="bibliography"><li><span id="MString2020"><div class="csl-block csl-content"><div class="csl-block csl-title"><b>Abstracting Strings for Model Checking of C Programs</b>. </div><div class="csl-block csl-author">By Lauko, H., Olliaro, M., Cortesi, A. and Ročkai, P.</div><div class="csl-block csl-event">In <i>Applied Sciences: Static Analysis Techniques (SAT)</i></div></div></span>

<div id="MString2020-materials">
  
  <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#abstract-MString2020" aria-expanded="false" aria-controls="abstract-MString2020">
  Abstract
  </button>
  

  
  <button class="btn btn-link" type="button">
  <a href="https://divine.fi.muni.cz/2020/mstring/">Web</a>
  </button>
  

  
  <div class="collapse" id="abstract-MString2020">
    <hr />
    Data type abstraction plays a crucial role in software verification. In this paper, we introduce a domain for abstracting strings in the C programming language, where strings are managed as null-terminated arrays of characters. The new domain M-String is parametrized on an index (bound) domain and a character domain. By means of these different constituent domains, M-Strings captures shape information on the array structure as well as value information on the characters occurring in the string. By tuning these two parameters, M-String can be easily tailored for specific verification tasks, balancing precision against complexity. The concrete and the abstract semantics of basic operations on strings are carefully formalized, and soundness proofs are fully detailed. Moreover, for a selection of functions contained in the standard C library, we provide the semantics for character access and update, enabling an automatic lifting of arbitrary string-manipulating code into our new domain. An implementation of abstract operations is provided within a tool that automatically lifts existing programs into the M-String domain along with an explicit-state model checker. The accuracy of the proposed domain is experimentally evaluated on real-case test programs, showing that M-String can efficiently detect real-world bugs as well as to prove that program does not contain them after they are fixed.
    <hr />
  </div>
  
</div>
</li>
<li><span id="Decomp2020"><div class="csl-block csl-content"><div class="csl-block csl-title"><b>On Symbolic Execution of Decompiled Programs</b>.</div><div class="csl-block csl-author">By Korenčik, L., Ročkai, P., Lauko, H. and Barnat, J.</div><div class="csl-block csl-event">In <i>Software Quality, Reliability, and Security (QRS)</i></div></div></span>

<div id="Decomp2020-materials">
  
  <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#abstract-Decomp2020" aria-expanded="false" aria-controls="abstract-Decomp2020">
  Abstract
  </button>
  

  
  <button class="btn btn-link" type="button">
  <a href="https://divine.fi.muni.cz/2020/decompile/">Web</a>
  </button>
  

  
  <div class="collapse" id="abstract-Decomp2020">
    <hr />
    In this paper, we present a combination of existing and new tools that together make it possible to apply formal verification methods to programs in the form of x86_64 machine code. Our approach first uses a decompilation tool (remill) to extract low-level intermediate representation (LLVM) from the machine code. This step consists of instruction translation(i.e. recovery of operation semantics), control flow extraction and address identification. The main contribution of this paper is the second step, which builds on data flow analysis and refinement of indirect (i.e. data-dependent) control flow. This step makes the processed bitcode much more amenable to formal analysis.To demonstrate the viability of our approach, we have compiled a set of benchmark programs into native executables and analysed them using two LLVM-based tools: DIVINE, a software model checker and KLEE, a symbolic execution engine. We have compared the outcomes to direct analysis of the same programs.
    <hr />
  </div>
  
</div>
</li></ol>

<hr />

<p>2019</p>
<ol class="bibliography"><li><span id="Sym2019"><div class="csl-block csl-content"><div class="csl-block csl-title"><b>Extending DIVINE with Symbolic Verification Using SMT</b>.</div><div class="csl-block csl-author">By Lauko, H., Štill, V., Ročkai, P. and Barnat, J.</div><div class="csl-block csl-event">In <i>Tools and Algorithms for the Construction and Analysis of Systems (TACAS)</i></div></div></span>

<div id="Sym2019-materials">
  
  <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#abstract-Sym2019" aria-expanded="false" aria-controls="abstract-Sym2019">
  Abstract
  </button>
  

  
  <button class="btn btn-link" type="button">
  <a href="https://divine.fi.muni.cz/2019/sv-comp-smt/">Web</a>
  </button>
  

  
  <div class="collapse" id="abstract-Sym2019">
    <hr />
    DIVINE is an LLVM-based verification tool focusing on analysis of real-world C and C++ programs. Such programs often interact with their environment, for example via inputs from users or network. When these programs are analyzed, it is desirable that the verification tool can deal with inputs symbolically and analyze runs for all inputs. In DIVINE, it is now possible to deal with input data via symbolic computation instrumented into the original program at the level of LLVM bitcode. Such an instrumented program maintains symbolic values internally and operates directly on them. Instrumentation allows us to enhance the tool with support for symbolic data without substantial modifications of the tool itself. Namely, this competition contribution uses SMT formulae for representation of input data.
    <hr />
  </div>
  
</div>
</li>
<li><span id="MString2019"><div class="csl-block csl-content"><div class="csl-block csl-title"><b>String Abstraction for Model Checking of C Programs</b>.</div><div class="csl-block csl-author">By Cortesi, A., Lauko, H., Olliaro, M. and Ročkai, P.</div><div class="csl-block csl-event">In <i>Model Checking Software (SPIN)</i></div></div></span>

<div id="MString2019-materials">
  
  <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#abstract-MString2019" aria-expanded="false" aria-controls="abstract-MString2019">
  Abstract
  </button>
  

  
  <button class="btn btn-link" type="button">
  <a href="https://divine.fi.muni.cz/2019/mstring/">Web</a>
  </button>
  

  
  <div class="collapse" id="abstract-MString2019">
    <hr />
    Automatic abstraction is a powerful software verification technique. In this paper, we elaborate an abstract domain for C strings, that is, null-terminated arrays of characters. We describe the abstract semantics of basic string operations and prove their soundness with regards to previously established concrete semantics of those operations. In addition to a selection of string functions from the standard C library, we provide semantics for character access and update, enabling automatic lifting of arbitrary string-manipulating code into the domain.
    <hr />
  </div>
  
</div>
</li></ol>

<hr />

<p>2018</p>
<ol class="bibliography"><li><span id="Sym2018"><div class="csl-block csl-content"><div class="csl-block csl-title"><b>Symbolic Computation via Program Transformation</b>.</div><div class="csl-block csl-author">By Lauko, H., Ročkai, P. and Barnat, J.</div><div class="csl-block csl-event">In <i>Theoretical Aspects of Computing (ICTAC)</i></div></div></span>

<div id="Sym2018-materials">
  
  <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#abstract-Sym2018" aria-expanded="false" aria-controls="abstract-Sym2018">
  Abstract
  </button>
  

  
  <button class="btn btn-link" type="button">
  <a href="https://divine.fi.muni.cz/2018/sym/">Web</a>
  </button>
  

  
  <div class="collapse" id="abstract-Sym2018">
    <hr />
    Symbolic computation is an important approach in automated program analysis. Most state-of-the-art tools perform symbolic computation as interpreters and directly maintain symbolic data. In this paper, we show that it is feasible, and in fact practical, to use a compiler-based strategy instead. Using compiler tooling, we propose and implement a transformation which takes a standard program and outputs a program that performs a semantically equivalent, but partially symbolic, computation. The transformed program maintains symbolic values internally and operates directly on them; therefore, the program can be processed by a tool without support for symbolic manipulation.
    <hr />
  </div>
  
</div>
</li></ol>

<hr />

<p>2017</p>
<ol class="bibliography"><li><span id="Divine2017"><div class="csl-block csl-content"><div class="csl-block csl-title"><b>Model Checking of C and C++ with DIVINE 4</b>.</div><div class="csl-block csl-author">By Baranová, Z., Barnat, J., Kejstová, K., Kučera, T., Lauko, H., Mrázek, J., Ročkai, P. and Štill, V.</div><div class="csl-block csl-event">In <i>Automated Technology for Verification and Analysis (ATVA)</i></div></div></span>

<div id="Divine2017-materials">
  
  <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#abstract-Divine2017" aria-expanded="false" aria-controls="abstract-Divine2017">
  Abstract
  </button>
  

  
  <button class="btn btn-link" type="button">
  <a href="https://divine.fi.muni.cz/2017/divine4/">Web</a>
  </button>
  

  
  <div class="collapse" id="abstract-Divine2017">
    <hr />
    The fourth version of the DIVINE model checker provides a modular platform for verification of real-world programs. It is built around an efficient interpreter of LLVM code which, together with a small, verification-oriented operating system and a set of runtime libraries, enables verification of code written in C and C++.
    <hr />
  </div>
  
</div>
</li>
<li><span id="Sym2017"><div class="csl-block csl-content"><div class="csl-block csl-title"><b>Optimizing and Caching SMT Queries in SymDIVINE</b>.</div><div class="csl-block csl-author">By Mrázek, J., Jonáš, M., Štill, V., Lauko, H. and Barnat, J.</div><div class="csl-block csl-event">In <i>Tools and Algorithms for the Construction and Analysis of Systems (TACAS)</i></div></div></span>

<div id="Sym2017-materials">
  
  <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#abstract-Sym2017" aria-expanded="false" aria-controls="abstract-Sym2017">
  Abstract
  </button>
  

  

  
  <div class="collapse" id="abstract-Sym2017">
    <hr />
    This paper presents a new version of the tool SymDIVINE, a model-checker for concurrent C/C++ programs. SymDIVINE uses a control-explicit data-symbolic approach to model checking, which allows for the bit-precise verification of programs with inputs, by representing data part of a program state by a first-order bit-vector formula. The new version of the tool employs a refined representation of symbolic states, which allows for efficient caching of smt queries. Moreover, the new version employs additional simplifications of first-order bit-vector formulas, such as elimination of unconstrained variables from quantified formulas. All changes are documented in detail in the paper.
    <hr />
  </div>
  
</div>
</li></ol>

<hr />

<p>2016</p>
<ol class="bibliography"><li><span id="Sym2016"><div class="csl-block csl-content"><div class="csl-block csl-title"><b>SymDIVINE: Tool for Control-Explicit Data-Symbolic State Space Exploration</b>.</div><div class="csl-block csl-author">By Mrázek, J., Bauch, P., Lauko, H. and Barnat, J.</div><div class="csl-block csl-event">In <i>Model Checking Software (SPIN)</i></div></div></span>

<div id="Sym2016-materials">
  
  <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#abstract-Sym2016" aria-expanded="false" aria-controls="abstract-Sym2016">
  Abstract
  </button>
  

  
  <button class="btn btn-link" type="button">
  <a href="https://github.com/paradise-fi/SymDIVINE">Web</a>
  </button>
  

  
  <div class="collapse" id="abstract-Sym2016">
    <hr />
    We present SymDIVINE: a tool for bit-precise model checking of parallel C and C++ programs. It builds upon LLVM compiler infrastructure, hence, it uses LLVM IR as an input formalism. Internally, SymDIVINE extends the standard explicit-state state space exploration with SMT machinery to handle non-deterministic data values. As such, SymDIVINE is on a halfway between a symbolic executor and an explicit-state model checker. The key differentiating aspect present in SymDIVINE is the ability to decide about equality of two symbolically represented states preventing thus repeated exploration of the state space graph. This is crucially important in particular for verification of parallel programs where the state space graph is full of diamond-shaped subgraphs.
    <hr />
  </div>
  
</div>
</li></ol>


  </section>

</article>

      </div>
    </div>
<div class="py-5 border-top">
  <div class="container">

    <div class="row">

      <div class="col-sm">
        <ul class="list-unstyled">
          <li>Henrich Lauko</li><li>
              <a href="mailto:henrich.lau@gmail.com">
                henrich.lau@gmail.com
              </a>
            </li></ul>
      </div>


      <div class="col-sm text-right">
        <p>Personal website of Henrich Lauko</p>
      </div>

    </div>

  </div>
</div>
</body>

</html>
