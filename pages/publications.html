<!DOCTYPE html>
<html lang="en"><head>
 <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http:/xlauko.github.io/feed.xml" title="Henrich Lauko" /><script src="/assets/javascript/bootstrap/jquery.min.js"></script>
  <script src="/assets/javascript/bootstrap/bootstrap.bundle.min.js"></script>
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
</head>
<body><nav class="navbar navbar-expand-lg navbar-dark bg-primary">
  <div class="container">
    <a class="navbar-brand" rel="author" href="/">Henrich Lauko</a>

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
      aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto"><li class="nav-item">
            <a class="nav-link" href="/">About</a>
          </li>
        <li class="nav-item">
            <a class="nav-link" href="/pages/publications">Publications</a>
          </li>
        <li class="nav-item">
            <a class="nav-link" href="/pages/projects">Projects</a>
          </li>
        <li class="nav-item">
            <a class="nav-link" href="https://github.com/xlauko">Github</a>
          </li>
        </ul>
    </div>
  </div>
</nav>
<div class="py-5">
      <div class="container page-content">
          <article>

  <header>
    <h4></h4>
  </header>

  <section>
    <p>Thesis</p>

<ul>
  <li>Abstractions via Program Transformations (<em>advanced master thesis</em>)
    <div id="amaster-materials">
  <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#abstract-amaster" aria-expanded="false" aria-controls="abstract-amaster">
  Abstract
  </button>

  <button class="btn btn-link" type="button">
  <a href="https://is.muni.cz/th/uqf69/?lang=en">Web</a>
  </button>

  <div class="collapse" id="abstract-amaster">
    <hr />
    In computer-aided verification, most of the tools leverage abstraction techniques to reduce the complexity of analyzed systems. Even though these techniques are widely adopted, they are usually tightly integrated into tools, causing undesired complexity, and neglect any reusable design. In my research, I focus on the investigation of abstraction-based techniques used in program verification as abstract interpretation, counterexample guided abstraction or symbolic execution. For these techniques, I devise self-contained alternatives and general-purpose analyses. As a solution for self-contained abstraction, I propose a transformation-based method. This method utilizes instrumentation to insert abstraction directly to the program and consequently quits of responsibility for abstraction from the verification tools. Up until now, I have developed transformation-based symbolic execution and string abstraction for explicit model checkers. In the future, I plan to generalize the transformation-based technique for a wider variety of abstract domains such as predicate or pointer abstraction. Furthermore, I intend to adapt traditional abstraction refinement techniques to the self-contained abstraction.
    <hr />
  </div>
</div>
  </li>
  <li>Symbolic Model Checking via Program Transformations (<em>master thesis</em>)
    <div id="master-materials">
  <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#abstract-master" aria-expanded="false" aria-controls="abstract-master">
  Abstract
  </button>

  <button class="btn btn-link" type="button">
  <a href="https://is.muni.cz/th/owq0x/?lang=en">Web</a>
  </button>

  <div class="collapse" id="abstract-master">
    <hr />
    To show reliability of software, developers usually reach out for testing and static analysis. However, to prove correctness, all behaviours of a program need to be checked. In this respect, formal verification methods aim to provide an automated approach to verification. A big obstacle are inputs because they massively increase the number of behaviours of the program. In this thesis, we present a technique which enables verification tools to perform automated checking of programs with inputs. A generally known approach is to interpret operations with input values in an abstract way. In this case, abstraction needs to be implemented in the verification tool. We propose that instead, an abstraction can be compiled into the program. Hence, the program can be verified by a tool even though the tool itself does not support abstraction of inputs. We implement the proposed approach as an LLVM-to-LLVM transformation which inserts an abstraction to the program. The applicability of the approach is demonstrated by transforming programs to represent their inputs symbolically. This, in turn, enables an essentially explicit-state model checker to verify the program. For evaluation purposes, we have chosen DIVINE as the model checker.
    <hr />
  </div>
  <i class="fa fa-trophy"> Dean's award for an Outstanding Final Thesis</i>
</div>
  </li>
  <li>Introduction to Data Structures in Examples (<em>bachelor thesis</em>)
    <div id="bachelor-materials">
  <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#abstract-bachelor" aria-expanded="false" aria-controls="abstract-bachelor">
  Abstract
  </button>

  <button class="btn btn-link" type="button">
  <a href="https://is.muni.cz/th/vlg4z/?lang=en">Web</a>
  </button>

  <div class="collapse" id="abstract-bachelor">
    <hr />
    This thesis presents methods and structures proposed for teaching and home study of data structures. The thesis describes creation process of concrete exercises and their solutions. A part of exercises cover practical implementations, that contains code templates to be solved and a package of tests. Themes covered in the thesis are elementary data structures such as stack, queue, linked list and their modifications. Moreover, the thesis covers dynamic data structures for searching: binary heap, searching trees, red-black trees and B-trees. The thesis also comprehends data structures for the implementation of dictionaries.
  </div>
</div>
  </li>
</ul>

<hr />

<p>2022</p>
<ol class="bibliography"><li><span id="Pointers2022"><div class="csl-block csl-content"><div class="csl-block csl-title"><b>Verification of Programs Sensitive To&nbsp;Heap&nbsp;Layout</b>. </div><div class="csl-block csl-author">By Lauko, H., Korenčik, L. and Ročkai, P.</div><div class="csl-block csl-event">In <i>ACM Trans. Softw. Eng. Methodol.</i>, vol. 31, no. 4</div></div></span>

<div id="Pointers2022-materials">
  
  <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#abstract-Pointers2022" aria-expanded="false" aria-controls="abstract-Pointers2022">
  Abstract
  </button>
  

  
  <button class="btn btn-link" type="button">
  <a href="https://divine.fi.muni.cz/2021/pointers/">Web</a>
  </button>
  

  
  <div class="collapse" id="abstract-Pointers2022">
    <hr />
    Most C and C++ programs use dynamically allocated memory (often known as a heap) to store and organize their data. In practice, it can be useful to compare addresses of different heap objects, for instance, to store them in a binary search tree or a sorted array. However, comparisons of pointers to distinct objects are&nbsp;inherently ambiguous: The address order of two objects can be reversed in different executions of the same program, due to the nature of the allocation algorithm and other external factors.This poses a significant challenge to program verification, since a sound verifier must consider all possible behaviors of a program, including an arbitrary reordering of the heap. A naive verification of all possibilities, of course, leads to a&nbsp;combinatorial explosion of the state space: For this reason, we propose an under-approximating abstract domain that can be soundly refined to consider all relevant heap orderings.We have implemented the proposed abstract domain and evaluated it against several existing software verification tools on a&nbsp;collection of pointer-manipulating programs. In many cases, existing tools only consider a single fixed heap order, which is a source of unsoundness. We&nbsp;demonstrate that using our abstract domain, this unsoundness can be repaired at only a very modest performance cost. Additionally, we show that, even though many verifiers ignore it, ambiguous behavior is present in a considerable fraction of programs from software verification competition (sv-comp).
    <hr />
  </div>
  
</div>
</li>
<li><span id="Spot2022"><div class="csl-block csl-content"><div class="csl-block csl-title"><b>From Spot 2.0 to Spot 2.10: What’s New?</b></div><div class="csl-block csl-author">By Duret-Lutz, A., Renault, E., Colange, M., Renkin, F., Gbaguidi Aisse, A., Schlehuber-Caissier, P., Medioni, T., Martin, A., Dubois, J., Gillard, C. and Lauko, H.</div><div class="csl-block csl-event">In <i>Computer Aided Verification</i></div></div></span>

<div id="Spot2022-materials">
  
  <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#abstract-Spot2022" aria-expanded="false" aria-controls="abstract-Spot2022">
  Abstract
  </button>
  

  

  
  <div class="collapse" id="abstract-Spot2022">
    <hr />
    Spot is a C++17 library for LTL and }}\backslashomega }}ω-automata manipulation, with command-line utilities, and Python bindings. This paper summarizes its evolution over the past six years, since the release of Spot 2.0, which was the first version to support }}\backslashomega }}ω-automata with arbitrary acceptance conditions, and the last version presented at a conference. Since then, Spot has been extended with several features such as acceptance transformations, alternating automata, games, LTL synthesis, and more. We also shed some lights on the data-structure used to store automata.
    <hr />
  </div>
  
</div>
</li>
<li><span id="Lauko2022optimization"><b>On the Optimization of Equivalent Concurrent Computations</b>. 2022</span>

<div id="Lauko2022optimization-materials">
  
  <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#abstract-Lauko2022optimization" aria-expanded="false" aria-controls="abstract-Lauko2022optimization">
  Abstract
  </button>
  

  

  
  <div class="collapse" id="abstract-Lauko2022optimization">
    <hr />
    In this submission, we explore the use of equality saturation to optimize concurrent computations. A concurrent environment gives rise to new optimization opportunities, like extracting a common concurrent subcomputation. To our knowledge, no existing equality saturation framework allows such an optimization. The challenge with concurrent environments is that they require non-local reasoning since parallel computations are inherently unrelated and disjoint. This submission presents a new approach to optimizing equivalent concurrent computations: extending e-graphs to capture equal concurrent computations in order to replace them with a single computation.
    <hr />
  </div>
  
</div>
</li>
<li><span id="Lart2022"><div class="csl-block csl-content"><div class="csl-block csl-title"><b>LART: Compiled Abstract Execution</b>.</div><div class="csl-block csl-author">By Lauko, H. and Ročkai, P.</div><div class="csl-block csl-event">In <i>Tools and Algorithms for the Construction and Analysis of Systems</i></div></div></span>

<div id="Lart2022-materials">
  
  <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#abstract-Lart2022" aria-expanded="false" aria-controls="abstract-Lart2022">
  Abstract
  </button>
  

  

  
  <div class="collapse" id="abstract-Lart2022">
    <hr />
    LART – LLVM Abstraction and Refinement Tool – originates from the divine model-checker, in which it was employed as an abstraction toolchain for the llvm interpreter. In this contribution, we present a stand-alone tool that does not need a verification backend but performs the verification natively. The core idea is to instrument abstract semantics directly into the program and compile it into a native binary that performs program analysis. This approach provides a performance gain of native execution over the interpreted analysis and allows compiler optimizations to be employed on abstracted code, further extending the analysis efficiency. Compilation-based abstraction introduces new challenges solved by lart, like domain interaction of concrete and abstract values simulation of nondeterministic runtime or constraint propagation.
    <hr />
  </div>
  
</div>
</li></ol>

<hr />

<p>2021</p>
<ol class="bibliography"></ol>

<hr />

<p>2020</p>
<ol class="bibliography"><li><span id="MString2020"><div class="csl-block csl-content"><div class="csl-block csl-title"><b>Abstracting Strings for Model Checking of C Programs</b>. </div><div class="csl-block csl-author">By Lauko, H., Olliaro, M., Cortesi, A. and Ročkai, P.</div><div class="csl-block csl-event">In <i>Applied Sciences: Static Analysis Techniques (SAT)</i></div></div></span>

<div id="MString2020-materials">
  
  <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#abstract-MString2020" aria-expanded="false" aria-controls="abstract-MString2020">
  Abstract
  </button>
  

  
  <button class="btn btn-link" type="button">
  <a href="https://divine.fi.muni.cz/2020/mstring/">Web</a>
  </button>
  

  
  <div class="collapse" id="abstract-MString2020">
    <hr />
    Data type abstraction plays a crucial role in software verification. In this paper, we introduce a domain for abstracting strings in the C programming language, where strings are managed as null-terminated arrays of characters. The new domain M-String is parametrized on an index (bound) domain and a character domain. By means of these different constituent domains, M-Strings captures shape information on the array structure as well as value information on the characters occurring in the string. By tuning these two parameters, M-String can be easily tailored for specific verification tasks, balancing precision against complexity. The concrete and the abstract semantics of basic operations on strings are carefully formalized, and soundness proofs are fully detailed. Moreover, for a selection of functions contained in the standard C library, we provide the semantics for character access and update, enabling an automatic lifting of arbitrary string-manipulating code into our new domain. An implementation of abstract operations is provided within a tool that automatically lifts existing programs into the M-String domain along with an explicit-state model checker. The accuracy of the proposed domain is experimentally evaluated on real-case test programs, showing that M-String can efficiently detect real-world bugs as well as to prove that program does not contain them after they are fixed.
    <hr />
  </div>
  
</div>
</li>
<li><span id="Decomp2020"><div class="csl-block csl-content"><div class="csl-block csl-title"><b>On Symbolic Execution of Decompiled Programs</b>.</div><div class="csl-block csl-author">By Korenčik, L., Ročkai, P., Lauko, H. and Barnat, J.</div><div class="csl-block csl-event">In <i>Software Quality, Reliability, and Security (QRS)</i></div></div></span>

<div id="Decomp2020-materials">
  
  <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#abstract-Decomp2020" aria-expanded="false" aria-controls="abstract-Decomp2020">
  Abstract
  </button>
  

  
  <button class="btn btn-link" type="button">
  <a href="https://divine.fi.muni.cz/2020/decompile/">Web</a>
  </button>
  

  
  <div class="collapse" id="abstract-Decomp2020">
    <hr />
    In this paper, we present a combination of existing and new tools that together make it possible to apply formal verification methods to programs in the form of x86_64 machine code. Our approach first uses a decompilation tool (remill) to extract low-level intermediate representation (LLVM) from the machine code. This step consists of instruction translation(i.e. recovery of operation semantics), control flow extraction and address identification. The main contribution of this paper is the second step, which builds on data flow analysis and refinement of indirect (i.e. data-dependent) control flow. This step makes the processed bitcode much more amenable to formal analysis.To demonstrate the viability of our approach, we have compiled a set of benchmark programs into native executables and analysed them using two LLVM-based tools: DIVINE, a software model checker and KLEE, a symbolic execution engine. We have compared the outcomes to direct analysis of the same programs.
    <hr />
  </div>
  
</div>
</li></ol>

<hr />

<p>2019</p>
<ol class="bibliography"><li><span id="Sym2019"><div class="csl-block csl-content"><div class="csl-block csl-title"><b>Extending DIVINE with Symbolic Verification Using SMT</b>.</div><div class="csl-block csl-author">By Lauko, H., Štill, V., Ročkai, P. and Barnat, J.</div><div class="csl-block csl-event">In <i>Tools and Algorithms for the Construction and Analysis of Systems (TACAS)</i></div></div></span>

<div id="Sym2019-materials">
  
  <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#abstract-Sym2019" aria-expanded="false" aria-controls="abstract-Sym2019">
  Abstract
  </button>
  

  
  <button class="btn btn-link" type="button">
  <a href="https://divine.fi.muni.cz/2019/sv-comp-smt/">Web</a>
  </button>
  

  
  <div class="collapse" id="abstract-Sym2019">
    <hr />
    DIVINE is an LLVM-based verification tool focusing on analysis of real-world C and C++ programs. Such programs often interact with their environment, for example via inputs from users or network. When these programs are analyzed, it is desirable that the verification tool can deal with inputs symbolically and analyze runs for all inputs. In DIVINE, it is now possible to deal with input data via symbolic computation instrumented into the original program at the level of LLVM bitcode. Such an instrumented program maintains symbolic values internally and operates directly on them. Instrumentation allows us to enhance the tool with support for symbolic data without substantial modifications of the tool itself. Namely, this competition contribution uses SMT formulae for representation of input data.
    <hr />
  </div>
  
</div>
</li>
<li><span id="MString2019"><div class="csl-block csl-content"><div class="csl-block csl-title"><b>String Abstraction for Model Checking of C Programs</b>.</div><div class="csl-block csl-author">By Cortesi, A., Lauko, H., Olliaro, M. and Ročkai, P.</div><div class="csl-block csl-event">In <i>Model Checking Software (SPIN)</i></div></div></span>

<div id="MString2019-materials">
  
  <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#abstract-MString2019" aria-expanded="false" aria-controls="abstract-MString2019">
  Abstract
  </button>
  

  
  <button class="btn btn-link" type="button">
  <a href="https://divine.fi.muni.cz/2019/mstring/">Web</a>
  </button>
  

  
  <div class="collapse" id="abstract-MString2019">
    <hr />
    Automatic abstraction is a powerful software verification technique. In this paper, we elaborate an abstract domain for C strings, that is, null-terminated arrays of characters. We describe the abstract semantics of basic string operations and prove their soundness with regards to previously established concrete semantics of those operations. In addition to a selection of string functions from the standard C library, we provide semantics for character access and update, enabling automatic lifting of arbitrary string-manipulating code into the domain.
    <hr />
  </div>
  
</div>
</li></ol>

<hr />

<p>2018</p>
<ol class="bibliography"><li><span id="Sym2018"><div class="csl-block csl-content"><div class="csl-block csl-title"><b>Symbolic Computation via Program Transformation</b>.</div><div class="csl-block csl-author">By Lauko, H., Ročkai, P. and Barnat, J.</div><div class="csl-block csl-event">In <i>Theoretical Aspects of Computing (ICTAC)</i></div></div></span>

<div id="Sym2018-materials">
  
  <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#abstract-Sym2018" aria-expanded="false" aria-controls="abstract-Sym2018">
  Abstract
  </button>
  

  
  <button class="btn btn-link" type="button">
  <a href="https://divine.fi.muni.cz/2018/sym/">Web</a>
  </button>
  

  
  <div class="collapse" id="abstract-Sym2018">
    <hr />
    Symbolic computation is an important approach in automated program analysis. Most state-of-the-art tools perform symbolic computation as interpreters and directly maintain symbolic data. In this paper, we show that it is feasible, and in fact practical, to use a compiler-based strategy instead. Using compiler tooling, we propose and implement a transformation which takes a standard program and outputs a program that performs a semantically equivalent, but partially symbolic, computation. The transformed program maintains symbolic values internally and operates directly on them; therefore, the program can be processed by a tool without support for symbolic manipulation.
    <hr />
  </div>
  
</div>
</li></ol>

<hr />

<p>2017</p>
<ol class="bibliography"><li><span id="Divine2017"><div class="csl-block csl-content"><div class="csl-block csl-title"><b>Model Checking of C and C++ with DIVINE 4</b>.</div><div class="csl-block csl-author">By Baranová, Z., Barnat, J., Kejstová, K., Kučera, T., Lauko, H., Mrázek, J., Ročkai, P. and Štill, V.</div><div class="csl-block csl-event">In <i>Automated Technology for Verification and Analysis (ATVA)</i></div></div></span>

<div id="Divine2017-materials">
  
  <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#abstract-Divine2017" aria-expanded="false" aria-controls="abstract-Divine2017">
  Abstract
  </button>
  

  
  <button class="btn btn-link" type="button">
  <a href="https://divine.fi.muni.cz/2017/divine4/">Web</a>
  </button>
  

  
  <div class="collapse" id="abstract-Divine2017">
    <hr />
    The fourth version of the DIVINE model checker provides a modular platform for verification of real-world programs. It is built around an efficient interpreter of LLVM code which, together with a small, verification-oriented operating system and a set of runtime libraries, enables verification of code written in C and C++.
    <hr />
  </div>
  
</div>
</li>
<li><span id="Sym2017"><div class="csl-block csl-content"><div class="csl-block csl-title"><b>Optimizing and Caching SMT Queries in SymDIVINE</b>.</div><div class="csl-block csl-author">By Mrázek, J., Jonáš, M., Štill, V., Lauko, H. and Barnat, J.</div><div class="csl-block csl-event">In <i>Tools and Algorithms for the Construction and Analysis of Systems (TACAS)</i></div></div></span>

<div id="Sym2017-materials">
  
  <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#abstract-Sym2017" aria-expanded="false" aria-controls="abstract-Sym2017">
  Abstract
  </button>
  

  

  
  <div class="collapse" id="abstract-Sym2017">
    <hr />
    This paper presents a new version of the tool SymDIVINE, a model-checker for concurrent C/C++ programs. SymDIVINE uses a control-explicit data-symbolic approach to model checking, which allows for the bit-precise verification of programs with inputs, by representing data part of a program state by a first-order bit-vector formula. The new version of the tool employs a refined representation of symbolic states, which allows for efficient caching of smt queries. Moreover, the new version employs additional simplifications of first-order bit-vector formulas, such as elimination of unconstrained variables from quantified formulas. All changes are documented in detail in the paper.
    <hr />
  </div>
  
</div>
</li></ol>

<hr />

<p>2016</p>
<ol class="bibliography"><li><span id="Sym2016"><div class="csl-block csl-content"><div class="csl-block csl-title"><b>SymDIVINE: Tool for Control-Explicit Data-Symbolic State Space Exploration</b>.</div><div class="csl-block csl-author">By Mrázek, J., Bauch, P., Lauko, H. and Barnat, J.</div><div class="csl-block csl-event">In <i>Model Checking Software (SPIN)</i></div></div></span>

<div id="Sym2016-materials">
  
  <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#abstract-Sym2016" aria-expanded="false" aria-controls="abstract-Sym2016">
  Abstract
  </button>
  

  
  <button class="btn btn-link" type="button">
  <a href="https://github.com/paradise-fi/SymDIVINE">Web</a>
  </button>
  

  
  <div class="collapse" id="abstract-Sym2016">
    <hr />
    We present SymDIVINE: a tool for bit-precise model checking of parallel C and C++ programs. It builds upon LLVM compiler infrastructure, hence, it uses LLVM IR as an input formalism. Internally, SymDIVINE extends the standard explicit-state state space exploration with SMT machinery to handle non-deterministic data values. As such, SymDIVINE is on a halfway between a symbolic executor and an explicit-state model checker. The key differentiating aspect present in SymDIVINE is the ability to decide about equality of two symbolically represented states preventing thus repeated exploration of the state space graph. This is crucially important in particular for verification of parallel programs where the state space graph is full of diamond-shaped subgraphs.
    <hr />
  </div>
  
</div>
</li></ol>


  </section>

</article>

      </div>
    </div>
<div class="py-5 border-top">
  <div class="container">

    <div class="row">

      <div class="col-sm">
        <ul class="list-unstyled">
          <li>Henrich Lauko</li><li>
              <a href="mailto:henrich.lau@gmail.com">
                henrich.lau@gmail.com
              </a>
            </li></ul>
      </div>


      <div class="col-sm text-right">
        <p>Personal website of Henrich Lauko</p>
      </div>

    </div>

  </div>
</div>
</body>

</html>
