% 2022

@article{Pointers2022,
author = {Lauko, Henrich and Koren\v{c}ik, Luk\'{a}\v{s} and Ro\v{c}kai, Petr},
title = {Verification of Programs Sensitive To&nbsp;Heap&nbsp;Layout},
year = {2022},
issue_date = {October 2022},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {31},
number = {4},
issn = {1049-331X},
url = {https://doi.org/10.1145/3508363},
doi = {10.1145/3508363},
abstract = {Most C and C++ programs use dynamically allocated memory (often known as a heap) to store and organize their data. In practice, it can be useful to compare addresses of different heap objects, for instance, to store them in a binary search tree or a sorted array. However, comparisons of pointers to distinct objects are&nbsp;inherently ambiguous: The address order of two objects can be reversed in different executions of the same program, due to the nature of the allocation algorithm and other external factors.This poses a significant challenge to program verification, since a sound verifier must consider all possible behaviors of a program, including an arbitrary reordering of the heap. A naive verification of all possibilities, of course, leads to a&nbsp;combinatorial explosion of the state space: For this reason, we propose an under-approximating abstract domain that can be soundly refined to consider all relevant heap orderings.We have implemented the proposed abstract domain and evaluated it against several existing software verification tools on a&nbsp;collection of pointer-manipulating programs. In many cases, existing tools only consider a single fixed heap order, which is a source of unsoundness. We&nbsp;demonstrate that using our abstract domain, this unsoundness can be repaired at only a very modest performance cost. Additionally, we show that, even though many verifiers ignore it, ambiguous behavior is present in a considerable fraction of programs from software verification competition (sv-comp).},
journal = {ACM Trans. Softw. Eng. Methodol.},
month = {sep},
articleno = {71},
numpages = {27},
keywords = {program transformation, abstraction, refinement, Heap, pointers},
web = {https://divine.fi.muni.cz/2021/pointers/}
}

@InProceedings{Spot2022,
author="Duret-Lutz, Alexandre
and Renault, Etienne
and Colange, Maximilien
and Renkin, Florian
and Gbaguidi Aisse, Alexandre
and Schlehuber-Caissier, Philipp
and Medioni, Thomas
and Martin, Antoine
and Dubois, J{\'e}r{\^o}me
and Gillard, Cl{\'e}ment
and Lauko, Henrich",
editor="Shoham, Sharon
and Vizel, Yakir",
title="From Spot 2.0 to Spot 2.10: What's New?",
booktitle="Computer Aided Verification",
year="2022",
publisher="Springer International Publishing",
address="Cham",
pages="174--187",
abstract="Spot is a C++17 library for LTL and {\$}{\$}{\backslash}omega {\$}{\$}$\omega$-automata manipulation, with command-line utilities, and Python bindings. This paper summarizes its evolution over the past six years, since the release of Spot 2.0, which was the first version to support {\$}{\$}{\backslash}omega {\$}{\$}$\omega$-automata with arbitrary acceptance conditions, and the last version presented at a conference. Since then, Spot has been extended with several features such as acceptance transformations, alternating automata, games, LTL synthesis, and more. We also shed some lights on the data-structure used to store automata.",
isbn="978-3-031-13188-2",
url = {https://link.springer.com/chapter/10.1007/978-3-031-13188-2_9},
}



@misc{Lauko2022optimization,
      title={On the Optimization of Equivalent Concurrent Computations},
      author={Henrich Lauko and Lukáš Korenčik and Peter Goodman},
      year={2022},
      eprint={2208.06295},
      archivePrefix={arXiv},
      primaryClass={cs.DC},
      url = {https://arxiv.org/abs/2208.06295},
      abstract = {In this submission, we explore the use of equality saturation to optimize concurrent computations. A concurrent environment gives rise to new optimization opportunities, like extracting a common concurrent subcomputation. To our knowledge, no existing equality saturation framework allows such an optimization. The challenge with concurrent environments is that they require non-local reasoning since parallel computations are inherently unrelated and disjoint. This submission presents a new approach to optimizing equivalent concurrent computations: extending e-graphs to capture equal concurrent computations in order to replace them with a single computation.}
}

@inproceedings{Lart2022,
   author="Lauko, Henrich and Ročkai, Petr",
   editor="Fisman, Dana and Rosu, Grigore",
   title="LART: Compiled Abstract Execution",
   booktitle="Tools and Algorithms for the Construction and Analysis of Systems",
   year="2022",
   publisher="Springer International Publishing",
   address="Cham",
   pages="457--461",
   abstract="LART -- LLVM Abstraction and Refinement Tool -- originates from the divine model-checker, in which it was employed as an abstraction toolchain for the llvm interpreter. In this contribution, we present a stand-alone tool that does not need a verification backend but performs the verification natively. The core idea is to instrument abstract semantics directly into the program and compile it into a native binary that performs program analysis. This approach provides a performance gain of native execution over the interpreted analysis and allows compiler optimizations to be employed on abstracted code, further extending the analysis efficiency. Compilation-based abstraction introduces new challenges solved by lart, like domain interaction of concrete and abstract values simulation of nondeterministic runtime or constraint propagation.",
   isbn="978-3-030-99527-0",
   url = {https://link.springer.com/chapter/10.1007/978-3-030-99527-0_31},
}

% 2020

@article{MString2020,
   author = {Lauko, Henrich and Olliaro, Martina and Cortesi, Agostino and Ročkai, Petr},
   article_number = {10},
   doi = {http://dx.doi.org/10.3390/app10217853},
   keywords = {string analysis; model checking; abstract interpretation; abstract domain},
   issn = {2076-3417},
   journal = {Applied Sciences: Static Analysis Techniques (SAT)},
   title = {Abstracting Strings for Model Checking of C Programs},
   url = {https://www.mdpi.com/2076-3417/10/21/7853},
   web = {https://divine.fi.muni.cz/2020/mstring/},
   year = {2020},
   abstract="Data type abstraction plays a crucial role in software verification. In this paper, we introduce a domain for abstracting strings in the C programming language, where strings are managed as null-terminated arrays of characters. The new domain M-String is parametrized on an index (bound) domain and a character domain. By means of these different constituent domains, M-Strings captures shape information on the array structure as well as value information on the characters occurring in the string. By tuning these two parameters, M-String can be easily tailored for specific verification tasks, balancing precision against complexity. The concrete and the abstract semantics of basic operations on strings are carefully formalized, and soundness proofs are fully detailed. Moreover, for a selection of functions contained in the standard C library, we provide the semantics for character access and update, enabling an automatic lifting of arbitrary string-manipulating code into our new domain. An implementation of abstract operations is provided within a tool that automatically lifts existing programs into the M-String domain along with an explicit-state model checker. The accuracy of the proposed domain is experimentally evaluated on real-case test programs, showing that M-String can efficiently detect real-world bugs as well as to prove that program does not contain them after they are fixed."
}

@inproceedings{Decomp2020,
   author = {Korenčik, Lukáš and Ročkai, Petr and Lauko, Henrich and Barnat, Jiří},
   address = {Neuveden},
   doi = {http://dx.doi.org/10.1109/QRS51102.2020.00044},
   web = {https://divine.fi.muni.cz/2020/decompile/},
   editor = {Lisa O’Conner},
   keywords = {Decompilation, Symbolic Execution, McSema},
   booktitle="Software Quality, Reliability, and Security (QRS)",
   language = {eng},
   location = {Neuveden},
   isbn = {978-1-7281-8913-0},
   pages = {265-272},
   publisher = {IEEE Computer Society},
   title = {On Symbolic Execution of Decompiled Programs},
   year = {2020},
   abstract="In this paper, we present a combination of existing and new tools that together make it possible to apply formal verification methods to programs in the form of x86_64 machine code. Our approach first uses a decompilation tool (remill) to extract low-level intermediate representation (LLVM) from the machine code. This step consists of instruction translation(i.e. recovery of operation semantics), control flow extraction and address identification. The main contribution of this paper is the second step, which builds on data flow analysis and refinement of indirect (i.e. data-dependent) control flow. This step makes the processed bitcode much more amenable to formal analysis.To demonstrate the viability of our approach, we have compiled a set of benchmark programs into native executables and analysed them using two LLVM-based tools: DIVINE, a software model checker and KLEE, a symbolic execution engine. We have compared the outcomes to direct analysis of the same programs."
}

% 2019

@InProceedings{Sym2019,
author="Lauko, Henrich
and {\v{S}}till, Vladim{\'i}r
and Ro{\v{c}}kai, Petr
and Barnat, Ji{\v{r}}{\'i}",
editor="Beyer, Dirk
and Huisman, Marieke
and Kordon, Fabrice
and Steffen, Bernhard",
title="Extending DIVINE with Symbolic Verification Using SMT",
booktitle="Tools and Algorithms for the Construction and Analysis of Systems (TACAS)",
year="2019",
publisher="Springer International Publishing",
address="Cham",
pages="204--208",
abstract="DIVINE is an LLVM-based verification tool focusing on analysis of real-world C and C++ programs. Such programs often interact with their environment, for example via inputs from users or network. When these programs are analyzed, it is desirable that the verification tool can deal with inputs symbolically and analyze runs for all inputs. In DIVINE, it is now possible to deal with input data via symbolic computation instrumented into the original program at the level of LLVM bitcode. Such an instrumented program maintains symbolic values internally and operates directly on them. Instrumentation allows us to enhance the tool with support for symbolic data without substantial modifications of the tool itself. Namely, this competition contribution uses SMT formulae for representation of input data.",
isbn="978-3-030-17502-3",
web = {https://divine.fi.muni.cz/2019/sv-comp-smt/}
}

@InProceedings{MString2019,
author="Cortesi, Agostino
and Lauko, Henrich
and Olliaro, Martina
and Ro{\v{c}}kai, Petr",
editor="Biondi, Fabrizio
and Given-Wilson, Thomas
and Legay, Axel",
title="String Abstraction for Model Checking of C Programs",
booktitle="Model Checking Software (SPIN)",
year="2019",
publisher="Springer International Publishing",
address="Cham",
pages="74--93",
abstract="Automatic abstraction is a powerful software verification technique. In this paper, we elaborate an abstract domain for C strings, that is, null-terminated arrays of characters. We describe the abstract semantics of basic string operations and prove their soundness with regards to previously established concrete semantics of those operations. In addition to a selection of string functions from the standard C library, we provide semantics for character access and update, enabling automatic lifting of arbitrary string-manipulating code into the domain.",
isbn="978-3-030-30923-7",
web = {https://divine.fi.muni.cz/2019/mstring/}
}

% 2018

@InProceedings{Sym2018,
author="Lauko, Henrich
and Ro{\v{c}}kai, Petr
and Barnat, Ji{\v{r}}{\'i}",
editor="Fischer, Bernd
and Uustalu, Tarmo",
title="Symbolic Computation via Program Transformation",
booktitle="Theoretical Aspects of Computing (ICTAC)",
year="2018",
publisher="Springer International Publishing",
address="Cham",
pages="313--332",
abstract="Symbolic computation is an important approach in automated program analysis. Most state-of-the-art tools perform symbolic computation as interpreters and directly maintain symbolic data. In this paper, we show that it is feasible, and in fact practical, to use a compiler-based strategy instead. Using compiler tooling, we propose and implement a transformation which takes a standard program and outputs a program that performs a semantically equivalent, but partially symbolic, computation. The transformed program maintains symbolic values internally and operates directly on them; therefore, the program can be processed by a tool without support for symbolic manipulation.",
isbn="978-3-030-02508-3",
web = {https://divine.fi.muni.cz/2018/sym/}
}

% 2017
@InProceedings{Divine2017,
author="Baranov{\'a}, Zuzana
and Barnat, Ji{\v{r}}{\'i}
and Kejstov{\'a}, Katar{\'i}na
and Ku{\v{c}}era, Tade{\'a}{\v{s}}
and Lauko, Henrich
and Mr{\'a}zek, Jan
and Ro{\v{c}}kai, Petr
and {\v{S}}till, Vladim{\'i}r",
title="Model Checking of C and C++ with DIVINE 4",
booktitle="Automated Technology for Verification and Analysis (ATVA)",
year="2017",
publisher="Springer International Publishing",
address="Cham",
pages="201--207",
abstract="The fourth version of the DIVINE model checker provides a modular platform for verification of real-world programs. It is built around an efficient interpreter of LLVM code which, together with a small, verification-oriented operating system and a set of runtime libraries, enables verification of code written in C and C++.",
isbn="978-3-319-68167-2",
web = {https://divine.fi.muni.cz/2017/divine4/}
}

@InProceedings{Sym2017,
author="Mr{\'a}zek, Jan
and Jon{\'a}{\v{s}}, Martin
and {\v{S}}till, Vladim{\'i}r
and Lauko, Henrich
and Barnat, Ji{\v{r}}{\'i}",
editor="Legay, Axel
and Margaria, Tiziana",
title="Optimizing and Caching SMT Queries in SymDIVINE",
booktitle="Tools and Algorithms for the Construction and Analysis of Systems (TACAS)",
year="2017",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="390--393",
abstract="This paper presents a new version of the tool SymDIVINE, a model-checker for concurrent C/C++ programs. SymDIVINE uses a control-explicit data-symbolic approach to model checking, which allows for the bit-precise verification of programs with inputs, by representing data part of a program state by a first-order bit-vector formula. The new version of the tool employs a refined representation of symbolic states, which allows for efficient caching of smt queries. Moreover, the new version employs additional simplifications of first-order bit-vector formulas, such as elimination of unconstrained variables from quantified formulas. All changes are documented in detail in the paper.",
isbn="978-3-662-54580-5"
}


% 2016

@InProceedings{Sym2016,
author="Mr{\'a}zek, Jan
and Bauch, Petr
and Lauko, Henrich
and Barnat, Ji{\v{r}}{\'i}",
title="SymDIVINE: Tool for Control-Explicit Data-Symbolic State Space Exploration",
booktitle="Model Checking Software (SPIN)",
year="2016",
publisher="Springer International Publishing",
address="Cham",
pages="208--213",
abstract="We present SymDIVINE: a tool for bit-precise model checking of parallel C and C++ programs. It builds upon LLVM compiler infrastructure, hence, it uses LLVM IR as an input formalism. Internally, SymDIVINE extends the standard explicit-state state space exploration with SMT machinery to handle non-deterministic data values. As such, SymDIVINE is on a halfway between a symbolic executor and an explicit-state model checker. The key differentiating aspect present in SymDIVINE is the ability to decide about equality of two symbolically represented states preventing thus repeated exploration of the state space graph. This is crucially important in particular for verification of parallel programs where the state space graph is full of diamond-shaped subgraphs.",
isbn="978-3-319-32582-8",
web = {https://github.com/paradise-fi/SymDIVINE}
}
